МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 4 з дисципліни
Аналіз та рефакторинг коду















Виконав:                                                                Перевірив:
ст. гр. ПЗПІ-23-4                				ст. викладач кафедри ПІ
Єрмоленко Олександр					Сокорчук Ігор Петрович
	















Харків 2025


1 ІСТОРІЯ ЗМІН
      №
      Дата
Версія звіту
Опис змін та виправлень
      1
      09.01.2026
      0.1
      Початкова версія

      




2 ЗАВДАННЯ

1. Розробити будову програмного забезпечення ІоТ клієнта.
2. Створити UML діаграму прецедентів для ІоТ клієнта.
3. Розробити бізнес логіку (математину обробку пов?язаних із предметною областю даних) та функції налаштування ІоТ клієнта.
4. Створити діаграму діяльності для ІоТ клієнта.
5. Створити програмну реалізацію бізнес логіки та функцій налаштування ІоТ клієнта.
6. Перевірити роботу ІоТ клієнта.
7. Завантажити або оновити (при потребі) створений програмний код у GitHub репозиторій для лабораторних робіт у гілку репозиторію main.
8. Створити відеозапис демонстрації описаної у розділі 3.1 Vision & Scope. функціональності IoT клієнта та завантажити цей відеозапис у свій канал на YouTube. При завантаженні відеозапису потрібно обов?язково встановити у налаштуваннях для цього відео українську мову як мову відео та мову субтитрів до відео.
9. Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео.
10. Створити звіт до лабораторної роботи.
11. Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua.
12. Експортувати увесь створений звіт у текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт.


3 ОПИС ВИКОНАНОЇ РОБОТИ

	
     Уся система IoT-клієнта є комплексною програмною моделлю реальної екосистеми контролю доступу, побудованої за принципами промислових систем безпеки та «розумного дому». Вона демонструє повний життєвий цикл роботи пристроїв: від генерації фізичних сигналів та емуляції роботи електромеханічних вузлів до криптографічної перевірки, фільтрації шумів та передачі критичних даних у серверну інфраструктуру.
     Починається все з віртуального моделювання фізики пристроїв у класах SmartLockDevice та MotionSensorDevice (див. дод. В), які відіграють роль апаратного забезпечення: вони не просто зберігають стан «відкрито/закрито», а моделюють поведінку реального обладнання в часі. Рівень напруги батареї змінюється не лінійно, а піддається впливу випадкових мікро-коливань (шуму), характерних для хімічних елементів живлення, та зазнає різких просадок у моменти активації електромотора замка. Механізм замка має інерційність: двері не відкриваються миттєво, а проходять через стани розблокування ригеля та фізичного відкриття з урахуванням таймерів автозакриття. Датчик руху (MotionSensor) працює за ймовірнісною моделлю, симулюючи присутність людини з періодом, що запобігає дрижанню сигналу, типовому для дешевих PIR-сенсорів.
     Поверх цієї фізичної моделі побудована абстракція логіки управління, де кожен пристрій інкапсулює свої методи самодіагностики та взаємодії. Це реалізує принцип єдиної відповідальності: замок самостійно відповідає за валідацію локальних кодів доступу (TOTP) та контроль цілісності свого стану, а датчик за реєстрацію активності. Віртуальний контролер у головному циклі (див. дод. В main.py) опитує стани обох пристроїв, синхронізує їхню взаємодію (наприклад, відкриття замка автоматично тригерить спрацювання датчика руху, імітуючи вхід людини) та формує пакети телеметрії.
MQTT-клієнт (див. main.py) відіграє ключову роль як транспортний рівень, що забезпечує двосторонню асинхронну комунікацію. На відміну від пасивних систем моніторингу, тут реалізовано повноцінне дистанційне керування: клієнт не лише публікує події (events) у топіки зі структурою locks/{serial_number}/events, а й підписаний на командні топіки (/command). Використання механізму LWT (Last Will and Testament) дозволяє брокеру автоматично сповіщати сервер про аварійне відключення пристрою, гарантуючи достовірність статусу ONLINE/OFFLINE.
     Особливу увагу приділено аналітичній частині на стороні пристрою. Замість передачі сирих шумів на сервер, клас SmartLockDevice реалізує алгоритм ковзного середнього з використанням черги deque. Це дозволяє пристрою самостійно відрізняти природні коливання напруги від аномальних спадів, що свідчать про коротке замикання або деградацію батареї. Якщо поточне значення напруги відхиляється від усередненого тренду більше ніж на заданий поріг, пристрій встановлює прапорець BATTERY_DRAIN_ANOMALY безпосередньо у телеметрії.
     Така архітектура дозволяє також реалізувати логічні перевірки безпеки безпосередньо на рівні емуляції. Система здатна моделювати ситуації, коли програмний стан замка залишається LOCKED, але фізичний датчик положення дверей сигналізує OPEN. Усі події, включаючи штатні операції, аномалії живлення та спроби злому, детально логуються у локальний CSV-файл через клас DataLogger, що створює архів для подальшого аудиту та налагодження алгоритмів.
     Завершальним елементом є головний скрипт, який реалізує надійний цикл підключення до брокера та забезпечує безперервну роботу симуляції. Він дозволяє перевіряти складні сценарії взаємодії, такі як введення TOTP-коду, дистанційне блокування та реакція на втрату зв'язку, створюючи повноцінний цифровий двійник реальної системи контролю доступу.


4 ВИСНОВКИ
     
     У результаті виконання лабораторної роботи було створено повноцінну модульну IoT-систему контролю доступу, яка включає глибоку емуляцію апаратного забезпечення, двосторонню MQTT-комунікацію та реалізацію аналітики на стороні пристрою. Розроблена система моделює реальні умови експлуатації розумних замків, враховуючи фізику хімічних елементів живлення (шуми, нелінійний розряд, просадки напруги під навантаженням), інерційність електромоторів та часові затримки (cooldown) сенсорів руху. Використання генераторів випадкових чисел та сценаріїв аварійних ситуацій (наприклад, коротке замикання) дозволяє верифікувати стійкість алгоритмів у умовах, максимально наближених до реальних. Абстракція пристроїв реалізує принципи SOLID: кожен клас (SmartLockDevice, MotionSensorDevice) інкапсулює власну логіку стану та діагностики, що спрощує підтримку та розширення коду. Головний контролер виступає основним хабом, синхронізуючи роботу окремих компонентів у єдиний цикл. Передача даних здійснюється через протокол MQTT, що забезпечує не лише збір телеметрії, а й миттєве дистанційне керування (відкриття/блокування) з підтвердженням виконання. Замість простої ретрансляції даних, реалізовано концепцію розумного пристрою: модуль аналітики використовує алгоритм ковзного середнього для фільтрації шумів та самостійного виявлення аномалій живлення без участі сервера. Архітектура системи є автономною та масштабованою, що дозволяє використовувати розроблений клієнт як повноцінний цифровий двійник для навантажувального тестування серверної частини або як прототип прошивки реального мікроконтролера.






ДОДАТОК А

Графічні матеріали


Рисунок 1 — Діаграма прецедентів ІоТ клієнта







Рисунок 2 — Діаграма діяльності ІоТ клієнта

ДОДАТОК Б

Device_state.py
1. import time
2. import random
3. import csv
4. import json
5. from datetime import datetime
6. from collections import deque 
7. 
8. class DataLogger:
9.     def __init__(self, filename):
10.         self.filename = filename
11.         try:
12.             with open(self.filename, 'x', newline='') as f:
13.                 writer = csv.writer(f)
14.                 writer.writerow(["Timestamp", "Device", "Type", "Battery", "Payload", "AnomalyDetected"])
15.         except FileExistsError:
16.             pass
17. 
18.     def log(self, serial, device_type, battery, payload, is_anomaly=False):
19.         with open(self.filename, 'a', newline='') as f:
20.             writer = csv.writer(f)
21.             writer.writerow([
22.                 datetime.now().isoformat(),
23.                 serial,
24.                 device_type,
25.                 f"{battery}%",
26.                 json.dumps(payload),
27.                 "YES" if is_anomaly else "NO"
28.             ])
29. 
30. class SmartLockDevice:
31.     def __init__(self, serial):
32.         self.serial = serial
33.         self.voltage = 6.0
34.         self.is_locked = True
35.         self.door_position = "CLOSED"
36.         self.battery_anomaly = False
37.         
38.         self.history_size = 10
39.         self.voltage_history = deque(maxlen=self.history_size)
40.         self.ANOMALY_THRESHOLD = 0.2 
41.         
42.         for _ in range(self.history_size):
43.             self.voltage_history.append(self.voltage)
44. 
45.     def _check_anomaly_moving_average(self):
46.         if not self.voltage_history:
47.             return False
48.         avg_voltage = sum(self.voltage_history) / len(self.voltage_history)
49. 
50.         drop = avg_voltage - self.voltage
51.         self.voltage_history.append(self.voltage)
52. 
53.         if drop > self.ANOMALY_THRESHOLD:
54.             return True
55.         return False
56. 
57.     def tick(self):
58. 
59.         self.voltage -= random.uniform(0.00005, 0.0001)
60.   
61.         if self.voltage < 3.5: 
62.             self.voltage = 6.0
63. 
64.             self.voltage_history.clear()
65.             for _ in range(self.history_size):
66.                 self.voltage_history.append(6.0)
67. 
68.         if self._check_anomaly_moving_average():
69.             self.battery_anomaly = True
70.         else:
71.             self.battery_anomaly = False
72. 
73.     def open_lock(self):
74.         self.is_locked = False
75.         self.voltage -= 0.05
76.         self.door_position = "OPEN" 
77.         return True
78. 
79.     def auto_lock(self):
80.         self.is_locked = True
81.         self.door_position = "CLOSED"
82. 
83.     def close_lock(self):
84.         self.is_locked = True
85.         self.door_position = "CLOSED"
86.         self.voltage -= 0.05
87.         return True
88. 
89.     def simulate_battery_failure(self):
90.         self.voltage -= 1.5
91.         if self.voltage < 0: self.voltage = 0.1
92.         return True
93. 
94.     def get_telemetry(self):
95.         pct = int(((self.voltage - 3.5) / 2.5) * 100)
96.         
97.         payload = {
98.             "voltage": round(self.voltage, 3),
99.             "percentage": max(0, min(100, pct)),
100.             "rssi": random.randint(-75, -55),
101.             "status": "LOCKED" if self.is_locked else "UNLOCKED",
102.             "sensors": { "door": self.door_position }
103.         }
104. 
105.         if self.battery_anomaly:
106.             payload["error"] = "BATTERY_DRAIN_ANOMALY"
107. 
108.         return payload
109. 
110. class MotionSensorDevice:
111.     def __init__(self, serial):
112.         self.serial = serial
113.         self.voltage = 3.0
114.         self.motion_detected = False
115.         self.cooldown = 0
116. 
117.     def tick(self):
118.         self.voltage -= random.uniform(0.00001, 0.00005)
119.         if self.voltage < 2.0: self.voltage = 3.0
120. 
121.         if self.cooldown > 0:
122.             self.cooldown -= 1
123.             self.motion_detected = False
124.         else:
125.             if random.random() > 0.90:
126.                 self.motion_detected = True
127.                 self.cooldown = 5
128. 
129.     def get_telemetry(self):
130.         pct = int(((self.voltage - 2.0) / 1.0) * 100)
131.         return {
132.             "voltage": round(self.voltage, 3),
133.             "percentage": max(0, min(100, pct)),
134.             "rssi": random.randint(-80, -60),
135.             "sensors": { 
136.                 "motion": self.motion_detected,
137.                 "lux": random.randint(300, 500) 
138.             }
139.         }

main.py
1. import json
2. import time
3. import sys
4. import paho.mqtt.client as mqtt
5. import pyotp
6. from config import Config
7. from device_state import SmartLockDevice, MotionSensorDevice, DataLogger
8. 
9. print("[System] Script initializing...", flush=True)
10. 
11. logger = DataLogger(Config.LOG_FILE)
12. lock = SmartLockDevice(Config.LOCK_SERIAL)
13. sensor = MotionSensorDevice(Config.SENSOR_SERIAL)
14. 
15. if not Config.LOCK_SECRET:
16.     print(" WARNING: LOCK_SECRET is missing via env/config. Using random secret.", flush=True)
17.     totp = pyotp.TOTP(pyotp.random_base32(), interval=30)
18. else:
19.     totp = pyotp.TOTP(Config.LOCK_SECRET, interval=30)
20. 
21. def publish_telemetry(client, device_obj):
22.     data = device_obj.get_telemetry()
23.     topic = f"locks/{device_obj.serial}/events"
24.     try:
25.         client.publish(topic, json.dumps(data))
26.         
27.         device_type = "LOCK" if isinstance(device_obj, SmartLockDevice) else "SENSOR"
28.         logger.log(device_obj.serial, device_type, data['percentage'], data['sensors'])
29.     except Exception as e:
30.         print(f"Publish failed: {e}", flush=True)
31.     return data
32. 
33. def on_connect(client, userdata, flags, rc, properties=None):
34.     if rc == 0:
35.         print("[Hub] Connected to MQTT Broker", flush=True)
36.         client.subscribe(f"locks/{lock.serial}/command")
37.         client.publish(f"locks/{lock.serial}/status", "ONLINE", retain=True)
38.         client.publish(f"locks/{sensor.serial}/status", "ONLINE", retain=True)
39.     else:
40.         print(f"Connection failed code: {rc}", flush=True)
41. 
42. def on_message(client, userdata, msg):
43.     try:
44.         payload = json.loads(msg.payload.decode())
45.         
46.         if msg.topic == f"locks/{lock.serial}/command":
47.             action = payload.get("action")
48.             
49.             if action == "OPEN":
50.                 print("\n[Remote] Command OPEN received...", flush=True)
51.                 lock.open_lock()
52.                 
53.                 print("[Sensor] Motion detected (Simulated Entry)", flush=True)
54.                 sensor.motion_detected = True 
55.                 sensor.cooldown = 10
56.                 
57.                 publish_telemetry(client, lock)
58.                 publish_telemetry(client, sensor)
59. 
60.                 time.sleep(3)
61.                 lock.auto_lock()
62.                 print("[Lock] Auto-locked", flush=True)
63.                 publish_telemetry(client, lock)
64. 
65.             elif action == "LOCK":
66.                 print("\n[Remote] Command LOCK received...", flush=True)
67.                 lock.close_lock()
68.                 print("[Lock] Manually Locked", flush=True)
69.                 publish_telemetry(client, lock)
70. 
71.             elif action == "CHECK_PIN":
72.                 user_code = payload.get("code")
73.                 print(f"\n[Local Auth] Verifying PIN: {user_code}", flush=True)
74.                 
75.                 if totp.verify(user_code, valid_window=1):
76.                     print(f"PIN VALID! Unlocking door...", flush=True)
77.                     lock.open_lock()
78.                     publish_telemetry(client, lock)
79.                     
80.                     time.sleep(3)
81.                     lock.auto_lock()
82.                     print("[Lock] Auto-locked", flush=True)
83.                 else:
84.                     print(f"PIN INVALID!", flush=True)
85.                     
86.     except Exception as e:
87.         print(f"Error handling message: {e}", flush=True)
88. 
89. client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
90. client.on_connect = on_connect
91. client.on_message = on_message
92. 
93. print(f"Connecting to {Config.BROKER}:{Config.PORT}...", flush=True)
94. 
95. while True:
96.     try:
97.         client.connect(Config.BROKER, Config.PORT, 60)
98.         break
99.     except Exception as e:
100.         print(f"Waiting for Mosquitto ({e})", flush=True)
101.         time.sleep(5)
102. 
103. client.loop_start()
104. 
105. print(f"Device Secret loaded: {Config.LOCK_SECRET}", flush=True)
106. print("IoT Simulation Started. Press Ctrl+C to stop.\n", flush=True)
107. 
108. try:
109.     while True:
110.         lock.tick()
111.         sensor.tick()
112.         current_code = totp.now()
113.         lock_data = publish_telemetry(client, lock)
114.         sensor_data = publish_telemetry(client, sensor)
115. 
116.         print(f"[Stats] Lock: {lock_data['percentage']}% | Sensor: {sensor_data['percentage']}% | PIN: {current_code}", flush=True)
117.         
118.         time.sleep(5)
119. 
120. except KeyboardInterrupt:
121.     print("\nStopping simulation", flush=True)
122.     client.publish(f"locks/{lock.serial}/status", "OFFLINE", retain=True)
123.     client.loop_stop()
124.     client.disconnect()
125.
2


