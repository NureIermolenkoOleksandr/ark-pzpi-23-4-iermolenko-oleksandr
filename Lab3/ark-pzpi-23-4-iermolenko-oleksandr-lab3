МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 3 з дисципліни
Аналіз та рефакторинг коду










Виконав:                                                                Перевірив:
ст. гр. ПЗПІ-23-4               				ст. викладач кафедри ПІ
Єрмоленко Олександр					Сокорчук Ігор Петрович




















Харків 2025


1 ІСТОРІЯ ЗМІН
      №
      Дата
Версія звіту
      Опис змін та виправлень
      1
      09.01.2026
      0.1
      Початкова версія

      




2 ЗАВДАННЯ

1. Розробити бізнес логіку серверної частини програмної системи.
2. Розробити функції адміністрування серверної частини програмної системи.
3. Створити програмну реалізацію бізнес логіки та функцій адміністрування серверної частини.
4. Перевірити роботу серверної частини системи.
5. Завантажити або оновити (при потребі) створений програмний код у GitHub репозиторій для лабораторних робіт у гілку репозиторію main.
6. Створити відеозапис демонстрації описаної у розділі 3.1 Vision & Scope функціональності серверної частини та завантажити цей відеозапис у свій канал на YouTube для облікового запису в домені @nure.ua.  При завантаженні відеозапису потрібно обов?язково встановити у налаштуваннях для цього відео українську мову як мову відео та мову субтитрів до відео.
7. Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео.
8. Створити звіт до лабораторної роботи.
9. Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua.
10. Експортувати увесь створений звіт у простий текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт з вказаним у цих методичних вказівках іменем файла та директорії.


3 ОПИС ВИКОНАНОЇ РОБОТИ

     Система управління Smart Lock реалізує рольову модель доступу (RBAC), де права користувачів чітко розмежовані залежно від їхніх функціональних обов'язків та рівня відповідальності. У системі визначено шість основних ролей: SUPER_ADMIN, ORG_ADMIN, MANAGER, SECURITY, MAINTENANCE та TENANT. Нижче наведено детальний опис можливостей для ключових з них.
     Супер-адміністратор (SUPER_ADMIN) має повний і необмежений доступ до всіх модулів системи. Це єдина роль, яка має право керувати глобальними налаштуваннями безпеки та інфраструктурою на найвищому рівні. Лише супер-адміністратор може переглядати TOTP-секрети пристроїв для їх початкової прошивки. Критично важливою функцією є управління резервним копіюванням: він має доступ до створення повних дампів бази даних (backups/export), їх завантаження та аварійного відновлення системи (restore). Він також може змінювати ролі будь-яких користувачів та має доступ до всіх логів аудиту.
     Адміністратор організації (ORG_ADMIN) та Менеджер (MANAGER)  (див. дод. Б. рис. 3) відповідають за організацію фізичного доступу в будівлях. Їхні права зосереджені навколо сутностей "Інфраструктура" (buildings, rooms) та "Ключі доступу" (access_keys). Вони можуть створювати нові кімнати, прив'язувати до них пристрої та видавати цифрові ключі орендарям або співробітникам, встановлюючи часові рамки їх дії. Вони не мають доступу до технічних секретів пристроїв, але контролюють логіку доступу.
     Служба безпеки (SECURITY) та Технічний персонал (MAINTENANCE) - це спеціалізовані ролі для моніторингу. Охорона має доступ до модуля "Журнал подій" (event_logs) та аналітики ризиків, отримуючи сповіщення про спроби злому або аномальну поведінку. Технічний персонал фокусується на стані обладнання: вони бачать рівень заряду батарей, якість сигналу та статус підключення (ONLINE/OFFLINE), отримуючи завдання на заміну елементів живлення.
     Орендар (TENANT) - (див. дод. Б. рис. 2) це базова роль кінцевого користувача. Користувач із цією роллю має доступ до перегляду своїх активних ключів та історії власних входів. Головна функція орендаря - це ініціація відкриття дверей (POST /devices/:id/open) або генерація офлайн-кодів доступу. Він не має прав на зміну налаштувань системи, перегляд чужих логів або редагування інфраструктури.
     Для перевірки автентифікації та ролі використовується код (рядок 1-45), що реалізує захист маршрутів:
1. import jwt from 'jsonwebtoken';
2. import { prisma } from '../config/db.js';
3. 
4. export const authenticate = async (req, res, next) => {
5.   try {
6.     const authHeader = req.headers.authorization; 
7.     
8.     if (!authHeader || !authHeader.startsWith('Bearer ')) {
9.       return res.status(401).json({ error: 'Unauthorized: No token provided' });
10.     }
11. 
12.     const token = authHeader.split(' ')[1];
13. 
14.     const decoded = jwt.verify(token, process.env.JWT_SECRET);
15. 
16.     const user = await prisma.user.findUnique({ where: { id: decoded.userId } });
17.     if (!user || !user.isActive) {
18.       return res.status(401).json({ error: 'Unauthorized: User not found or inactive' });
19.     }
20. 
21.     req.user = {
22.       id: user.id,
23.       email: user.email,
24.       role: user.role
25.     };
26. 
27.     next();
28.   } catch (error) {
29.     return res.status(401).json({ error: 'Unauthorized: Invalid token' });
30.   }
31. };
32. 
33. export const authorize = (roles = []) => {
34.   return (req, res, next) => {
35.     if (!req.user) {
36.       return res.status(401).json({ error: 'Unauthorized' });
37.     }
38. 
39.     if (roles.length && !roles.includes(req.user.role)) {
40.       return res.status(403).json({ error: 'Forbidden: Insufficient rights' });
41.     }
42. 
43.     next();
44.   };
45. };
     Сервіс analyticsService.js аналізує стан безпеки та технічного здоров'я системи, працюючи як багатокритеріальна система прийняття рішень, що базується на телеметрії MQTT, часових рядах подій та математичних моделях. Його основна мета - перетворити потік технічних даних у осмислені алерти для охорони та техніків. Аналіз починається з агрегації даних: для заданого пристрою вибирається історія телеметрії (напруга, RSSI, статус дверей) за останній період. Це дозволяє нівелювати випадкові аномалії сигналу та виявити стійкі тренди.
     Аналіз живлення використовує математичну модель лінійної регресії. За останні N вимірювань будується графік падіння напруги батареї (див. дод. Б. рис.1). Якщо даних недостатньо, аналіз відкладається. Для достатньої кількості точок обчислюється нахил прямої, який інтерпретується як швидкість розряду. Система екстраполює момент часу, коли напруга впаде до критичного рівня (наприклад, 4.5В). Якщо цей момент настане протягом найближчих 14 днів, створюється пріоритетний алерт для ролі MAINTENANCE. Заміна батарей планується не коли замок вже вимкнувся, а на випередження.
     Аналіз аномальної поведінки (Z-Score) оцінюється через cтатистичний аналіз логів доступу. Для кожного користувача обчислюється середня кількість успішних входів за добу та стандартне відхилення (sigma) за останні 30 днів. Поточна активність порівнюється з цим історичним профілем. Якщо кількість відкриттів за поточну добу перевищує середнє значення більше ніж на 3 стандартних відхилення (Z-score > 3), це інтерпретується як аномалія (наприклад, крадіжка акаунту або несанкціонована передача доступу). Повідомлення містить розрахований коефіцієнт ризику
     
4 ВИСНОВКИ
     
     У ході виконання роботи було розроблено ключові функції адміністрування та інтелектуальної безпеки серверної частини IoT-системи для контролю доступу. Було реалізовано управління ієрархічною інфраструктурою (будівлі, кімнати, пристрої) та життєвим циклом цифрових ключів. Це дозволяє адміністраторам централізовано керувати конфігураціями замків, а менеджерам - миттєво надавати або відкликати права доступу для орендарів. Також реалізовано механізми обслуговування системи, функціонал повного резервного копіювання та відновлення бази даних . Ключовим елементом бізнес-логіки стала реалізація алгоритмів предиктивної аналітики на основі математичних моделей. Замість простої порогової логіки, система використовує лінійну регресію для аналізу тренду падіння напруги, що дозволяє точно прогнозувати дату відмови батареї та планувати обслуговування на випередження. Впроваджено статистичний аналіз поведінки користувачів (Z-Score) та криптографічну валідацію TOTP у реальному часі, що дозволяє системі виявляти аномалії (підозрілу активність) та запобігати несанкціо






ДОДАТОК А

Графічні матеріали


Рисунок 1 - Діаграма активності аналізу батареї

Рисунок 2 - Діаграма взаємодії орендаря з системою


Рисунок 3 - Діаграма взаємодії менеджера із системою

















ДОДАТОК Б

Логіка сервісу AnalyticsService

1. import { prisma } from '../config/db.js';
2. 
3. export const predictBatteryFailure = async (deviceId) => {
4.   const data = await prisma.telemetry.findMany({
5.     where: { deviceId, voltage: { not: null } },
6.     orderBy: { timestamp: 'desc' },
7.     take: 10
8.   });
9. 
10.   if (data.length < 5) return { error: 'Not enough data for prediction' };
11. 
12.   const points = data.map(d => ({
13.     x: new Date(d.timestamp).getTime(),
14.     y: Number(d.voltage)
15.   }));
16. 
17.   const n = points.length;
18.   const sumX = points.reduce((a, b) => a + b.x, 0);
19.   const sumY = points.reduce((a, b) => a + b.y, 0);
20.   const sumXY = points.reduce((a, b) => a + b.x * b.y, 0);
21.   const sumXX = points.reduce((a, b) => a + b.x * b.x, 0);
22. 
23.   const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
24.   const intercept = (sumY - slope * sumX) / n;
25. 
26.   const CRITICAL_VOLTAGE = 4.5;
27. 
28.   if (slope >= 0) return { status: 'Stable', predictedFailureDate: null };
29. 
30. 
31.   const failureTime = (CRITICAL_VOLTAGE - intercept) / slope;
32.   
33.   return {
34.     deviceId,
35.     currentVoltage: points[0].y,
36.     status: 'Draining',
37.     predictedFailureDate: new Date(failureTime).toISOString(),
38.     daysRemaining: Math.floor((failureTime - Date.now()) / (1000 * 60 * 60 * 24))
39.   };
40. };
41. 
42. export const calculateUserZScore = async (userId) => {
43.   const logs = await prisma.eventLog.findMany({
44.     where: { 
45.       userId, 
46.       eventType: 'ACCESS_GRANTED',
47.       timestamp: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
48.     }
49.   });
50. 
51.   if (logs.length < 10) return { score: 0, status: 'Normal (Low Data)' };
52. 
53.   const loginsPerDay = {};
54.   logs.forEach(log => {
55.     const day = log.timestamp.toISOString().split('T')[0];
56.     loginsPerDay[day] = (loginsPerDay[day] || 0) + 1;
57.   });
58. 
59.   const counts = Object.values(loginsPerDay);
60. 
61.   const mean = counts.reduce((a, b) => a + b, 0) / counts.length;
62.   const variance = counts.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / counts.length;
63.   const stdDev = Math.sqrt(variance);
64. 
65.   if (stdDev === 0) return { score: 0, status: 'Stable' };
66. 
67.   const today = new Date().toISOString().split('T')[0];
68.   const todayCount = loginsPerDay[today] || 0;
69. 
70.   const zScore = (todayCount - mean) / stdDev;
71. 
72.   let status = 'Normal';
73.   if (zScore > 3) status = 'Anomaly (High Activity)';
74.   if (zScore < -3) status = 'Anomaly (Low Activity)'; 
75. 
76.   return {
77.     userId,
78.     todayCount,
79.     averageDaily: mean.toFixed(2),
80.     zScore: zScore.toFixed(2),
81.     status
82.   };
83. }; 

ДОДАТОК В
     Специфікація:

1. Роль: SUPER_ADMIN (Глобальний адміністратор)
Має повний доступ до системи, включаючи критичні налаштування та відновлення.
* Системне обслуговування:
o GET /api/backups/export - Завантажити повний дамп бази даних (Disaster Recovery).
o POST /api/backups/import - Відновити базу даних з файлу (повне перезаписування).
* Управління користувачами:
o GET /api/users - Перегляд усіх користувачів системи.
o PATCH /api/users/:id/role - Призначення ролей (наприклад, підвищення звичайного юзера до Менеджера).
* Секретні дані:
o GET /api/devices/:id/secret - Перегляд TOTP-секрету пристрою (для первинної прошивки мікроконтролерів).

2. Роль: ORG_ADMIN та MANAGER (Управління офісом)
Відповідають за фізичну інфраструктуру та надання доступу людям.
* Управління інфраструктурою:
o POST /api/buildings - Створення нової будівлі/офісу.
o POST /api/rooms - Додавання кімнат у будівлю.
o POST /api/devices - Реєстрація нових замків та датчиків 
* Контроль доступу (Ключова функція):
o POST /api/access-keys/issue - Видача цифрового ключа користувачу (встановлення прав доступу до конкретних дверей).
o DELETE /api/access-keys/:id - Відкликання ключа (заборона доступу).
* Моніторинг:
o GET /api/dashboard - Перегляд зведеної статистики по своїм будівлям (кількість активних ключів, проблемні пристрої).

3. Роль: SECURITY (Служба безпеки)
Фокусується на виявленні загроз, розслідуванні інцидентів та реагуванні.
* Аудит та Розслідування:
o GET /api/logs - Пошук по журналу подій (фільтри: type=ACCESS_DENIED, type=DOOR_FORCED).
o GET /api/analytics/risk/:userId - Перевірка рівня підозрілості користувача (Z-Score аналіз аномальної поведінки).
* Реагування:
o GET /api/alerts - Перегляд активних сповіщень про злам.

4. Роль: MAINTENANCE (Технічний персонал)
Відповідає за справність обладнання, заміну батарей та стабільність зв'язку.
* Діагностика:
o GET /api/devices?status=OFFLINE - Пошук пристроїв, що втратили зв'язок.
o GET /api/telemetry/:deviceId - Перегляд історії показників (напруга, RSSI) для діагностики.
* Предиктивне обслуговування:
o GET /api/analytics/battery/:id - Отримання прогнозу дати відмови батареї (Linear Regression).
* Налаштування:
o PUT /api/devices/:id/config - Зміна технічних параметрів (гучність звуку, чутливість датчиків, час автозакриття).

5. Роль: TENANT (Орендар / Співробітник)
Кінцевий користувач, який використовує систему для проходу в приміщення.
* Доступ:
o POST /api/devices/:id/open - Віддалене відкриття дверей через додаток.
o POST /api/access-keys/verify-pin - Використання одноразового коду (TOTP) для входу.
* Інформація:
o GET /api/access-keys/my - Перегляд списку доступних дверей та термінів дії ключів.
o GET /api/dashboard - Особиста статистика (останні входи).

6. Роль: PUBLIC (Неавторизований доступ / IoT)
Ендпоінти, доступні без токена користувача.
* POST /api/auth/login - Вхід у систему (отримання JWT).
* POST /api/auth/register - Реєстрація нового акаунту.
* GET /api/api-docs - Документація API (Swagger UI).



2










